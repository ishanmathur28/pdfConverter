<p>COMPUTER GRAPHICS</p><p>(UCS 505)</p><p>Project:</p><p>Rubik’s Cube Solver</p><p></p><p>Submitted By:</p><p>Daksh Azad        102003145</p><p>Sudiksha Raheja 102003187</p><p>GROUP NO. 4</p><p>B.E. THIRD YEAR – COE</p><p></p><p>Submitted To:</p><p>Dr. Amrita Kaur</p><p></p><p></p><p></p><p>Computer Science and Engineering Department Thapar Institute of Engineering and Technology </p><p>Patiala – 147001</p><p>Table of Contents</p><p></p><p></p><p></p><p></p><p></p><p></p><p>INTRODUCTION</p><p></p><p>The Rubik's Cube is a classic puzzle game that has been popular for decades. It consists of a cube with six faces, each composed of nine smaller squares of different colors. The objective of the game is to solve the puzzle by rearranging the smaller squares so that each face of the cube has only one color.</p><p></p><p>In recent years, there has been growing interest in creating 3D simulations of the Rubik's Cube using computer graphics techniques. These simulations offer several advantages over physical cubes, such as the ability to manipulate the cube with greater ease and speed, as well as the ability to generate infinite variations of the cube.</p><p></p><p>In this project, we present a 3D simulation of the Rubik's Cube using various concepts of computer graphics. Our goal was to create a visually appealing and interactive simulation that accurately represents the mechanics of the Rubik's Cube.</p><p></p><p>We used a combination of programming languages and graphics libraries to develop the simulation, including C++, OpenGL, and GLSL. We also implemented several algorithms for cube manipulation, such as the basic layer-by-layer method.</p><p></p><p>In this report, we will discuss the design and implementation of our Rubik's Cube simulation in detail. We will also evaluate the performance of our simulation and discuss potential future directions for this project.</p><p></p><p></p><p>COMPUTER GRAPHICS CONCEPTS USED</p><p></p><p>3D modeling - The Rubik's Cube was modeled as a 3D object composed of smaller cubes. Each smaller cube was represented as a vertex in a 3D space, with its position and color determined by its location within the Rubik's Cube. This allowed us to create a realistic and accurate representation of the Rubik's Cube that could be easily manipulated in 3D space.</p><p></p><p>Transformations - In order to allow users to rotate all the faces of the cube, change the rotation speed, and rotate the entire cube, we utilized various transformations. This included translation, rotation, and scaling transformations. Translation was used to move the Rubik's Cube to different locations in 3D space. Rotation was used to change the orientation of the Rubik's Cube and its individual faces. Scaling was used to adjust the size of the Rubik's Cube and its individual cubes.</p><p></p><p>Animation - Animation involves creating the illusion of motion in a 3D object. In this project, animation is used to make the windmill blades rotate about the x, y, and z axes. </p><p></p><p>User interaction - User interaction involves allowing the user to control the windmill animation. In this project, the user can control the speed of the windmill blades using keyboard input. </p><p></p><p>Texturing - In order to apply the colors of the Rubik's Cube to the individual cubes, we utilized texturing techniques. We created a texture map that represented the colors of each face of the Rubik's Cube, and applied it to the individual cubes. This allowed us to create a realistic and accurate representation of the Rubik's Cube's color scheme.</p><p></p><p></p><p>Overall, these computer graphics concepts were essential for creating a visually appealing and interactive Rubik's Cube simulation. By utilizing these techniques, we were able to create a realistic and accurate representation of the Rubik's Cube that users can manipulate in real-time.</p><p></p><p>USER DEFINED FUNCTIONS</p><p></p><p></p><p></p><p></p><p>3(a)  DESIGN</p><p></p><p></p><p></p><p>Application</p><p>Program</p><p></p><p></p><p></p><p>Description</p><p></p><p></p><p></p><p>    Mouse Event                                                                                                          Menu Event</p><p></p><p>Mouse events: </p><p>When mouse event occurs, the ASCII code for the corresponding coordinates that generate the event and the location of mouse are returned. </p><p>Mouse callback function is:</p><p>glutMouseFunc (mouse); </p><p>Void mouse (int btn, int state, int x, int y) { </p><p>if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) </p><p>begin = x; </p><p>} </p><p></p><p>Menu Entry: </p><p>GLUT provides one additional feature, pop_up menus, which we can use with the mouse to create sophisticated interactive application.</p><p>glutCreateMenu (); </p><p>glutAddMenuEntry (); </p><p>glutAttachMenu (GLUT_RIGHT_BUTTON);</p><p></p><p>3(b)   ALGORITHM</p><p></p><p>STEP 1: Define vertices for 27 cubes which are used to compose </p><p> one whole cube known as “Rubiks cube”.</p><p>STEP 2: Define colors for each cube of the Rubiks cube to </p><p> distinguish one cube from the other and as well as color for </p><p> the speed meter, which is used to control the speed of </p><p> rotation. </p><p></p><p>Output( ) function:</p><p>STEP 3: This function is used to display the message using the </p><p> Commands glutBitmapCharacter( ) and glRasterpos*( ).</p><p></p><p>Polygon( ) function:</p><p>STEP 4: Draw a polygon via list of vertices with the line of 3 pixels </p><p> wide.</p><p></p><p>Colorcube( ) function:</p><p>STEP 5: Map vertices to faces. Hence the use of colorcube function has done 27 times with different prefixes for all the 27 </p><p> cubes amongst which one with no color, 6 with one color, </p><p> 12 with two colors and 8 with three colors on it.</p><p></p><p>Speedmeter( ) function:</p><p>STEP 6: This function is used to define vertices for a speedmeter, </p><p>which is used to control the speed of rotation.</p><p></p><p></p><p>Display( ) function:</p><p>STEP 7: Clear the frame buffers and the z-buffer.</p><p>STEP 8: Invoke the function speedmeter and output. </p><p>STEP 9: Using the variables rotation and inverse the rotation for the </p><p> faces are defined, where if rotation is one and the inverse </p><p> flag is zero then the top face of the cube will be rotated in </p><p> the clockwise direction and incase if rotation is one and </p><p> also is the inverse flag then the top face of the cube will be </p><p> rotated in the anti-clockwise direction. </p><p> </p><p>STEP 10: The same procedure that has been specified in the step 9 is </p><p> adopted with different values for the rotation, such as </p><p> rotation with the value two is implemented for right </p><p> three for front, four for left, five for back and six for </p><p> bottom rotations respectively with the implementation of</p><p> inverse variable being same.</p><p> </p><p>STEP 11: Invoke the output function and swap the buffers.</p><p></p><p>Transpose( ) function:</p><p>STEP 12: This function is used to define the transpose for all the six </p><p> faces.</p><p></p><p>Topc( ) function:</p><p>STEP 13: This function is used to assign the values when the </p><p> operation is rotation of the top face. </p><p> </p><p></p><p>Frontc( ) function: </p><p>STEP 14: This function is used to assign the values when the operation is rotation of the front face.</p><p></p><p>Rightc( ) function:</p><p>STEP 15: This function is used to assign the values when the </p><p> operation is rotation of the right face.</p><p></p><p>Leftc( ) function:</p><p>STEP 16: This function is used to assign the values when the </p><p> operation is rotation of the left face.</p><p></p><p>Backc( ) function:</p><p>STEP 17: This function is used to assign the values when the </p><p> operation is rotation of the back face.</p><p></p><p>Bottomc( ) function:</p><p>STEP 18: This function is used to assign the values when the </p><p> operation is rotation of the bottom face.</p><p></p><p>Spincube( ) function:</p><p>STEP 19: This is function is an idle callback which rotates the cube </p><p> accordingly, if rotation is one and inverse is zero then </p><p> rotate the top face of the cube by 90 degrees in the </p><p> clockwise direction and if inverse is one then rotate the</p><p> same face by 90 degree in the anti-clockwise direction.</p><p></p><p>STEP 20: The same procedure is implemented for the other faces of </p><p> the cube with different rotation values.</p><p>STEP 21: The cube is redisplayed after the rotation.</p><p></p><p>Motion( ) function:</p><p>STEP 22: This is used to rotate the cube about the selected axis.</p><p></p><p>Mouse( ) function:</p><p>STEP 23: Mouse callback function. This allows user to give input through </p><p> mouse buttons. </p><p></p><p>Keyboard( ) function:</p><p>STEP 24: use the keys ‘a’,’s’,’d’,’f’,’g’,’h’ to rotate the faces of the </p><p> accordingly in the clockwise direction and the keys</p><p> ‘q’,’w’,’e’,’r’,’t’,’y’ to rotate in the anti-clockwise</p><p> direction.</p><p>STEP 25: use the keys ‘1’,’2’,’4’,’5’,’6’,’8’,’9’ are used to move the </p><p> viewer along the axis.</p><p>STEP 26: use the keys ‘m’ and ‘n’ to alter the value of the rotation </p><p> meter which controls the speed of the rotation.</p><p>STEP 27: use the key ‘o’ for the automatic solving of the cube.</p><p></p><p>Myreshape( ) function:</p><p>STEP 28: Define a viewport and set the matrix to projection and</p><p> modelview matrices.</p><p></p><p>Mymenu( ) function:</p><p>STEP 29: Define the actions corresponding to each entry in the </p><p> menu.</p><p>Main( ) function:</p><p>STEP 30: Both double and z-buffer is enabled. Invoke the start</p><p> function.</p><p>STEP 31: Add entries to the menu and link the menu to the right </p><p> mouse button. </p><p>STEP 32: Stop.</p><p></p><p>CODE</p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p>OUTPUT / SCREENSHOTS</p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p>FUTURE POTENTIAL</p><p>Incorporating machine learning algorithms to generate new and challenging configurations of the Rubik's Cube.</p><p></p><p>Adding multiplayer functionality to allow users to compete against each other to solve the cube.</p><p></p><p>Configuring the program to solve the cube on it’s own as done in real life.</p>